# Преговор част 1. Анализ на алгоритъм. Базови алгоритми за сортиране.

## Преговор част 1

https://docs.google.com/document/d/1XP9VW4dZ6l5NyaxF_45zcOBtCOR9UgQZzVXpUd_OQ3A/edit#heading=h.xwg6upnd043t

## Анализ на алгоритми

**1. Цели при създаване на алгоритъм**
- Простота
- Коректност
- Бързодействие

Как се оценява бързодействието? Чрез изследване на асимптотиката.
*Сложност* наричаме скоростта на нарастването на времето и паметта, необходими за изпълнението на даден алгоритъм, с нарастването на входните данни.
Ще означаваме размера на входните данни с **n**.

- Сложност по време - как расте времето за изпълнение при нарастване на входа
- Сложност по памет - как расте необходимата памет при нарастване на входа

**2. Нотации**
- *O*(Big-O):
*O(f)* - множеството от функции, които растат не по-бързо от *f*
- *Ω*(Big-Omega):
*Ω(f)* - множеството от функции, които растат не по-бавно от *f*
- *Θ*(Theta):
*Θ(f)* - множеството от функции, които растат със скоростта на *f*

**3. Свойства**

Нека c > 0 - константа. Тогава:
- *O(n + c)* = *O(n)* --- Адитивните константи се игнорират
- *O(c.n)* = *O(n)* --- Мултипликативните константи се игнорират
- Сложността на един алгоритъм се определя от тази функция, която расте най-бързо

**4. Често срещани функции**
  1. Константна
        * Практически най-добрата сложност
        * Не зависи от обема на входните данни
  2. Логаритмична
        * Двоично търсене, алгоритъм на Евклид
  3. Линейна
        * Среща се в алгоритми, които обработват всеки обект
  4. Квадратична
        * O(n^2)
  5. Кубична
        * O(n^3)
  6. Експоненциална
        * O(2^n)
        * O(n!)
        * O(n^n)
        * O(2^{n^2})

## Нарастване спрямо *n*

| *n* | 10 | 100 | 1 000 | 100 000 | 1 000 000 | 100 000 000 |
| --- | --- | --- | --- | --- | --- | --- |
| const = 5 | 5 | 5 | 5 | 5 | 5 | 5 |
| log(n) | 3 | 6 | 9 | 16 | 19 | 26 |
| n | 10 | 100 | 1 000 | 100 000 | 1 000 000 | 100 000 000 |
| n*log(n) | 33 | 664 | 9 966 | 1 660 964 | 19 931 568 | 2 657 542 475 |
| n^2 | 100 | 10 000 | 1 000 000 | 10 000 000 000 | 1 000 000 000 000 | 10^16 |
| n^3| 1 000 | 1 000 000 | 1 000 000 000 | 10^15 | 10^18 | 10^24 |
| 2^n | 1 024 | 10^30 | 10^300 | :turtle: | :turtle: | :turtle: |
| n! | 3 628 800 | 10^157 | 10^2567 | :snail: | :snail: | :snail: |
| n^n | 10 000 000 000 | 10^200 | 10^3000 | :skull: | :skull: | :skull: |

**5. Да се определи сложността на [функциите](https://github.com/IvanaHristova/introduction-to-programming-2023-2024/tree/main/sem13/complexity.cpp)**

## Сортиране

**1. Bubble Sort**

Познат като *метод на мехурчето*.
Работи на принципа на директни сравнения. Масивът се обхожда като се разменят съседни елементи, ако са в инверсия.

Въпроси:
1. Какво се случва след първото обхождане на масива?
2. Колко пъти трябва да бъде обходен масива, за да бъде сортиран?
3. Стабилен ли е алгоритъмът?

Предимства:
1. Има свойството да проверява дали масивът е сортиран ефикасно
2. Добър за учебна цел

**2. Selection Sort**

Познат като *метод на пряката селекция*.
Алгоритъмът сортира масива чрез последователни обхождания и търсене на най-малък елемент. Този елемент се разменя с елемента на *правилната* му позиция.

Предимства:
1. Прави минимален брой swap-ове: n - 1 (WC)

**3. Insertion Sort**

Алгоритъмът наподобява начина, по който картоиграч реди картите в ръката си.
Алгоритъмът строи сортиран масив като взима поредния необходен елемент и намира павилното му място измежду сортираните елементи.
Наивната имплементация на алгоритъма използва swap-ове. "Изтънчената" имплементация запазва елемента в отделна променлива и приплъзва елементите на сортирания подмасив надясно до намиране на правилната позиция. След това елементът се поставя на нея.

Предимства:
1. Добър при предварително сортиран масив (или почти сортиран)
2. По-ефикасен от предните два квадратични алгоритъма
3. Може да сортира масив с приемането му

**4. Анализ**

| \* | Bubble sort | Selection sort | Insertion sort |
| --- | --- | --- | --- |
| BC | *O(n)* | *O(n^2)* | *O(n)* |
| AC | *O(n^2)* | *O(n^2)* | *O(n^2)* |
| WC | *O(n^2)*  | *O(n^2)* | *O(n^2)* |
| Memory | *O(1)* | *O(1)* | *O(1)* |
| Stability | :heavy_check_mark: | ❌ | :heavy_check_mark: |
