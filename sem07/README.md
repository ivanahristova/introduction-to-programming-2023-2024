# Упражнение №7. Референции

## Reference - референция/псевдоним

- Алтернативно име за съществуваща променлива
- Декларира се чрез &
- Референцията трябва да се инициализира още при дефиницията
- След като веднъж е била декларирана, инициализирането е необратимо (обвързване за цял живот)
- Типът на референцията и на променливата трябва да съвпадат
- Ако функция получи референция към променлива, тя може да променя стойността на променливата директно

**Пример 1:**
```cpp
void example1(int number) { // копие
    number += 5;
}

void example2(int& number) { // псевдоним
    number += 5;
}

int main() {
    int a = 5;
    example1(a);
    example2(a);

    return 0;
}
```

**Пример 2:**
```cpp
// Няма да бъдат разменени стойностите на фактическите параметри, с които е извикана функцията
void swap(double a, double b) {
    double temp = a;
    a = b;
    b = temp;
}

// Ще бъдат разменени стойностите на фактическите параметри, с които е извикана функцията
void swap(double& a, double& b) {
    double temp = a;
    a = b;
    b = temp;
}
```

## Връщане на референция

- Когато се връща референция, **не** се връщате стойността на променливата, а **цялата** променлива
- Трябва да сме сигурни, че променливата, чиято референция връщате, съществува и след приключването на функцията, т.е. не се връща локално създаден обект

```cpp
int& errorProne() {
    int a = 5;
    return a;
}
// Недефинирано поведение, което компилаторът на Visual Studio, любезно заличава, но реално това е проблем и не всички компилатори го позволяват
```

## Указатели vs Псевдоними

| Указател | Псевдоним |
| --- | --- |
| ❌ Всеки път трябва да дереферираме пойнтър, ако искаме да извлечем стойността на променливата, към която сочи | ❌ Не може да сменя обекта, към който сочи |
| ❌ Ползва допълнително памет (пойнтърът е променлива, за която се заделя място в паметта, в което се записва адрес) | ❌ Задължително трябва да бъде инициализиран |
| ✔️ Има дефолтна нулева стойност | ✔️ Можем да ги третираме като нормални обекти |

## Задачи

**Задача** Какъв ще бъде резултатът от изпълнението на програмата:

```cpp
#include <iostream>

void g() {
    int ii = 0;
    int& rr = ii;
    rr++;
    std::cout << ii << std::endl;
    std::cout << rr << std::endl;

    int* pp = &rr;
    (*pp)++;
    std::cout << ii  << std::endl;

    pp++;
    std::cout << *pp << std::endl;

    pp--;
    std::cout << *pp << std::endl;
}

int main() {
    g();
}
```

**Задача** Дадена е квадратна матрица **A** с размери **n<sub>x</sub>n**. Изведете елементите й спираловидно, започвайки от горния ляв ъгъл.

**Пример**:<br>
```text
1 2 3 4
12 13 14 5
11 16 15 6
10 9 8 7
```
Изход: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16<br>

* Бонус: Да се направи същото с mxn матрица.

<br>

**Задача**  Магически палиндром като матрица съдържа палиндроми по редовете, колоните и двата си диагонала. Определете дали дадена матрица от символи (размер **N<sub>x</sub>N**) е магически палиндром.

**Пример**:<br>
Вход:
```text
a b a
b a b
a b a
```
Изход: Yes

---

```text
a b b a
9 a a 9
k o k o
a b b a
```
Изход: No

---

<br>

**Задача** Дадени са матриците **A** и **B**, с размери **NxM** и **PxQ**. Да се изведе произведението на **A** и **B**, ако това е възможно, или да се изведе съобщение, че не е.

---

<br>

**Задача** По даден входен масив, сортиран във възходящ ред, да се намери дали в него има диада със сума m.

---

<br>

**Задача** По даден входен масив, сортиран във възходящ ред, с две по две различни числа, да се намери броя на триадите със сума 0.
