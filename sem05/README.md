# Упражнение №5. Указатели. Едномерни масиви.

- Нека е дефинирана променлива: int number = 5;
- Всяка променлива има адрес в паметта, на който се съхранява нейната стойност.

**Указател**
- Синтаксис: T *<име>
- Дефинира указател към променлива от тип Т (параметризиран тип: ако T е тип данни, то T* е тип “указател към елемент от тип T”)
- Стойността на указател е адрес на данна от тип T или nullptr (т.е. указателят е променлива, която пази адрес(memory address) като стойност)
- Размера на указател зависи от архитектурата

**Оператор &**
- Служи за намиране (извличане) адреса на променливата, т.е. резултатът от прилагането на оператора е адресът на променливата
- Адресът се представя чрез шестнайсетично число

```cpp
int number = 5;

// Създаваме променлива от тип указател към int с име ptrToNumber
int* ptrToNumber = &number; // в нея съхраняваме адреса на number

std::cout << &number << " == " << ptrToNumber << std::endl;
```

```cpp
double *pointerToDouble = nullptr;
double doubleNumber = 1.23;
double *pointerToMyDoubleNumber = &doubleNumber;
double **pointerToPointerToMyDoubleNumber = &pointerToMyDoubleNumber;
```

- Адресът, който съдържа указателят, може да се променя.
- Може да се извършват промени по данните в съответния адрес.
- Указателят също притежава адрес.

```cpp
    bool* trickOrTreatWon = nullptr;
    bool treat = true;
    trickOrTreatWon = &treat;

    bool* trickOrTreatLost = trickOrTreatWon; // Двата пойнтъра имат една и съща стойност

    (*trickOrTreatLost)--; // Декрементираме втория

    *trickOrTreatWon = true;

    bool trick = *trickOrTreatLost;
    *trickOrTreatLost = false;

    treat = &trick;

    *trickOrTreatWon = 1;

    *trickOrTreatLost = !(*trickOrTreatWon);
```

**Основни операции**
- Рефериране - &<данна> (&<lvalue> връща като резултат <rvalue>)
- Дерефериране - *<указател> (\*<rvalue> връща като резултат <lvalue>!)
- Указателите могат да се сравняват чрез оператори за сравнение
- Върху указатели могат да се извършват аритметични операции
- Извеждане (<<) /Но няма въвеждане!/
- Операциите са дуални една на друга и се унищожават взаимно
  - &(*p) ⇐⇒ p
  - *(&x) ⇐⇒ x

**Nullptr**
- pointer literal(пойнтеров литерал).
- Не може да се вземе адреса му с &.
- nullptr сочи към адрес 0x00000000.

| nullptr | NULL |
| --- | --- |
| std::nullptr_t | #define NULL 0 |

```cpp
void myFunction(int* ptr) {
    std::cout << "Pointer version" << std::endl;
}

void myFunction(int value) {
    std::cout << "Non-pointer version" << std::endl;
}

int main() {
    myFunction(nullptr);
    myFunction(NULL);
    return 0;
}
```

### Указатели и константи

- Константен указател (който е константа)
  - int* const – константен указател
  - Може да се променя стойността на променливата, но НЕ може да се променя да сочи към друга променлива.
- Указател към константа (сочещ към константа)
  - const int* - указател към константа
  - int const* - указател към константа
  - НЕ може да се променя стойността на променливата, към която сочи

```cpp
const int * const == int const * const – константен пойнтър към константа

( int *) * const – константен пойнтър към пойнтър от тип int

( (int ) * const )* - пойнтър към константен пойнтър към int

( ( int const ) *) * - двоен пойнтър към константа от тип int

( ( int ) * const ) * const – константен пойнтър към константен пойнтър към int

( ( const int ) * const ) * const – константен пойнтър към константен пойнтър към константа от тип int
```

### Указателна аритметика

Можем да достъпваме не само клетката, към която даден указател сочи, ами и съседни на нея (например на някакъ отстъп).
За целта можем да ползваме аритметични операции като: +, -, ++, ...
Колко клетки можем да прескочим зависи от типа на указателя
В общия случай това е <отстъп> * <размера на типа, рефериран от указателя>.

**Прескачане на n клетки**
- p + 2 означава “прескочи 2 байта напред”, ако char* p;
- p + 2 означава “прескочи 8 байта напред”, ако int* p;
- p + 2 означава “прескочи 16 байта напред”, ако double* p;

Така, ако имаме
T* p;
тогава p + i прескача i * sizeof(T) байта напред

### Масиви (с фиксирана дължина)

- Удобен начин за съхранение и манипулация на последователност от елементи от един и същи тип

Декларация на статичен масив:
- <тип> <име>[размер];
- При декларация всички елементи на масива имат случайни стойности
- Размерът на масив трябва да бъде зададен чрез константна променлива или число

Индексиране:
- Индексирането е начинът, по който достъпваме и манипулираме отделни елементи в масива
- Елементите в едномерен масив са подредени последователно и се номерират с индекси
- Индексите започват от 0 за първия елемент и увеличават се с 1 за всяка следваща позиция в масива, достигайки до n-1
- Индексите са цели числа (int), и те се използват за указване на конкретната позиция в масива

Пример:
```cpp
  int numbers[5]; // Декларация на масив с 5 елемента
  numbers[0] = 42; // Променя стойността на първия елемент на 42.
  int value = numbers[2]; // Прочита стойността на третия елемент и я записва в променливата "value".

  // Индексите за този масив ще бъдат следните:
  // numbers[0] сочи към първия (нулевия) елемент.
  // numbers[1] сочи към втория елемент.
  // numbers[2] сочи към третия елемент.
  // numbers[3] сочи към четвъртия елемент.
  // numbers[4] сочи към петия елемент.
```

Инициализация на статичен масив:
- Чрез въвеждане (четене от конзолата)
- Чрез инициализиращ списък
```cpp
  int arr[5] = {};           // [0, 0, 0, 0, 0]
  int arr[]  = {1, 2, 3, 4};  // [1,2,3,4]
  int arr[5] = {1,2,3};      // [1,2,3,0,0]
```

Индексите винаги
- Tрябва да бъдат цели числа
- Tрябва да са валидни позиции в масива (т.е., да не излизат извън границите на масива)
Ако опитате да достъпите елемент с невалиден индекс (извън размерите на масива), това може да доведе до нежелано поведение на програмата и до грешки, включително крашване.

Обобщение за масиви:

1. Размер на масива: Размерът на масива (броят на елементите в него) се задава при декларацията на масива и не може да се променя по време на изпълнение.
Например, int numbers[5] създава масив с 5 цели числа. Внимавайте да не излизате извън границите на масива при индексирането.

2. Инициализация: Масивите могат да бъдат инициализирани при декларацията с начални стойности.
Например:
```cpp
int numbers[5] = {1, 2, 3, 4, 5};
```

3. Достъп до елементите: Елементите на масивите могат да бъдат достъпвани и променяни с помощта на индекси. Проверявайте винаги, че индексите са валидни и не излизат извън границите на масива.

4. Цикли за обхождане: За обхождане на всички елементи в масива често се използват цикли като for или while.
Пример:
```cpp
for (size_t i = 0; i < 5; i++) {
    cout << numbers[i] << " ";
}
```

❓ Защо [size_t](https://en.cppreference.com/w/cpp/types/size_t)

5. Масиви и указатели: В C++, масивите представляват указател към първия си елемент. Това означава, че можете да използвате указателна аритметика за работа с масиви.

6. Предаване на масиви като параметри: Масивите могат да бъдат предавани като параметри на функции. Обаче трябва да обърнете внимание на тяхната размерност, тъй като в C++ не се предава информация за размера на масива, когато той се подава на функция.

# Задачи

1. Да се напише функция, която разменя стойностите на две променливи.
#
2. Да се напише функция, които извежда стойностите на масив с дължина n. Използвайте указателна аритметика. Eлементите на масива са цели числа.
#
3. Да се напише функция, която приема целочислен масив и връща броя на инверсиите в него.
#
4. Да се напише функция, която приема два масива с една и съща дължина и връща броя на елементите, които са на една и съща позиция в масивите и са еднакви.
<details open>
<summary>Пример</summary>
Масив 1: 7 3 -1 2 10<br>
Масив 2: 1 3 -3 2 11<br>
Резултат: 2<br>
Пояснение: Елементът на индекс 1 и в двата масива е 3. Елементът на индекс 3 и в двата масива е две.<br>
</details>
#
5. Дадени са 10 числа в диапазон 0 - 65535.
a) Да се провери дали редицата е "редица-трион" (числата се редуват по големина)
<details open>
<summary>Пример</summary>
1 2 1 2 1 2 1 2 1 2 - Редицата е трион<br>
1 6 2 3 1 7 2 3 1 9 - Редицата е трион<br>
15 10 15 12 18 13 20 17 22 14 25 - Редицата е трион<br>
</details>
б) Да се изведат числата от редицата в нарастващ ред
в) Да се изведат числата от редицата в намаляващ ред
#
6. Да се напише програма, която приема 5 естествени числа, запазва ги и извежда най-малкото и най-голямото от тях. Числата, които ще се въвеждат са между: -32768 и 32766
<details open>
<summary>Пример</summary>
<b>Вход:</b><br>
7 3 -1 2 10<br>
<b>Изход:</b><br>
-1 10<br>
</details>
#
7. Да се напише функция, която приема целочислен масив и връща сбора от всички негови елементи, които са четни числа
#
8. Да се напише функция, която приема целочислен масив и го пренарежда така, че четните числа да се намират преди нечетните.
#
9. Нека е даден масив от числени стойности (double). Да се напишат функции за:
- minOfArray, която връща стойността на най-малкия елемент от масива
- maxOfArray, която връща стойността на най-големия елемент
- sumOfArray, която връща сбора на елементите в масива
- productOfArray, която връща тяхното произведение.
#
10. Нека е даден масив от булеви стойности. Да се напишат функции за:
- any, която връща дали някоя от тях е истина (true)
- all, която връща дали всички са истина
- findFirst, която връща индекса на първата стойност, която е истина.
#
11.Да се напише функция, която пренарежда елементите на масив така, че на първо място да стои най-големият, след него – най-малкият, след това – вторият най-голям и т.н.
<details open>
<summary>Пример</summary>
[5, 2, 1, 6, 7, 4] -> [7, 1, 6, 2, 5, 4]<br>
</details>
#
12. Да се напише програма, която извежда колко пъти се среща всяка цифра по подадено цяло число. Числото може да съдържа между 1 и 12 цифри.
#
13. Да се напише функция, която приема цяло (long long) число и връща дали то съдържа всяка от цифрите (от 0 до 9 вкл.)
#
14. Напишете функция, която приема цяло число и връща най-често срещаната цифра в числото.
#
15. По въведен масив от n на брой естествени числа, да се преместят всички нули в края на масива,
запазвайки наредбата на останалите елементи.
<details open>
<summary>Пример</summary>
<b>Вход:</b><br>
5 2 0 3 7 0 1 0<br>
<b>Изход:</b><br>
5 2 3 7 1 0 0 0<br>
</details>
#
16. Да се дефинира функция, която приема целочислен масив и цифра и връща
- колко общо пъти дадена цифрата се среща във всички елементи на масива
- ако имаме прави да "задраскваме" цифри от всяко число, но не да ги пренареждаме, то колко от елементите на масива могат да бъдат преобразувани до числото 13
- ако имаме право да "задраскваме" цифри и да ги пренареждаме, то колко от елементите на масива могат да бъдат преобразувани до числото 13
#
17. Да се напише функция, която приема два целочислени масива (с потенциално различни дължини) и отпечатва всички елементи, които се срещат в и двата.
#
18. Дадени са две числови редици. Да се провери дали са образувани от едно и също множество.
<details open>
<summary>Пример</summary>
<b>Вход:</b><br>
5 7<br>
1 3 4 1 3<br>
1 3 3 4 1 1 3<br>
<b>Изход:</b><br>
Yes<br>
</details>
#
19. Да се напише функция, която приема целочислен масив и пренарежда елементите му така, че всички прости числа в масива да се намират преди всички съставни числа и връща броя на простите числа в масива.
#
20. Дефинирайте функция, която приема целочислен масив и отпечатва стартовия индекс и дължината на най-дългата последователност от повтарящи се последователни числа в масива.
