# Упражнение №8. Динамично заделяне на памет

- Динамично заделените обекти имат живот, независим от това къде са създадени
- Динамично заделените обекти съществуват докато не бъдат експлицитно освободени

## Оператори за работа с динамична памет

- В C++ динамичната памет се менижира посредством два оператора
- **new** - заделя памет за обект (на тази стъпка може да имаме и инициализация) и връща пойнтър към новосъздадения обект
- **delete** - посредством пойнтър към динамично заделен обект, разрушава обекта и освобождава паметта асоциираната с него памет (паметта за този обект е била заделена използвайки оператора new)

## Оператор **new**

### Динамично заделяне на променливи

```cpp
int *number = new int; // number е динамично заделен, неинициализиран int
```

Можем да инициализираме:
- По време на създаването на обекта
- Посредством конструктори (с кръгли скоби),
- С инициализиращ списък (с къдрави скоби)

```cpp
int *p1 = new int; // стойността на *p1 не е дефинирана
int *p2 = new int(); // стойността на *p2 е 0
```

### Динамично заделяне на константни обекти (const)

```cpp
const int *pci = new const int(1024);
```

- Както на константите, динамично заделените константни обекти трябва да се инициализират
- Пойнтърът, който се връща от операторът new е пойнтър към константа

## Памет

- В C++, има 3 начина за заделяне на памет за съхранение на данни
• Статична памет (static memory): съществува докато програмата се изпълнява
• Стекова памет (stack memory): автоматична; алокира се когато направим извикване към функция и се освобождава когато изпълнението на функцията приключи
• Динамична памет (dynamic memory, heap): алокира се с оператора new и се деалокира (за да може да се презиползва) с оператора delete

**Изразходване на паметта (memory exhaustion)**

- Възможно е паметта в heap-а да бъде изчерпана.
- В такъв момент при опит за заделяне на паметт с new ще бъде хвърлено изключение bad_alloc.
- Това поведение може да бъде заглушено с:
```cpp
int *p1 = new int; // ако не успеем да заделим памет, new ще върне null пойнтър ще хвърли std::bad_alloc
int *p2 = new (nothrow) int; // ако не успеем да заделим памет, new ще върне null пойнтър
```

## Оператор **delete**

- Динамично заделените обекти съществуват докато не бъдат експлицитно освободени

### Освобождаване на динамично заделена памет

```cpp
int* p = new int(10);
delete p; // p трябва да сочи към динамично заделен обект или да е занулен

const int *pconst = new const int(1024);
delete pconst; // освобождава се константен обект
```

Недефинирано поведение имаме при:
- Освобождаване на памет с оператора delete, която не е била заделена от оператора new
- Освобождаване на една и съща памет повече от веднъж

```cpp
int i;
int* p1 = &i, * p2 = nullptr;
delete i; // грешка: i не е дефинирано
delete p1; // недефинирано: p1 не е бил заделен с оператора new, ами сочи към локална променлива
delete p2; // ок: винаги можем да прилагаме оператора delete върху нулпойнтър
```

## Проблеми
⚠️ Не освобождаваме паметта когато обектите повече няма да се ползват: memory leak
⚠️ Освобождаваме паметта когато обектите все още са в употреба и пойнтърите към тези "обекти" сочат памет, която вече не е валидна

## Динамични масиви

- Задалянето на динамичен масив с X елемента връща пойнтър към първия му елемент
```cpp
int *arr = new int[10];
```

- Размерът на динамичен масив трябва да бъде цяло число, но не е нужно да бъде константен
```cpp
int n;
std::cin >> n;
int *arr = new int[n];

delete[] arr;
```

- Инициализация на динамично заделен масив
```cpp
int *arr = new int[10]; // Масив с 10 неинициализирани елемента
int *arr2 = new int[10](); // Инициализира 10-те елемента с дефолтна стойност (нула)
int *arr3 = new int[10]{0,1,2,3,4,5,6,7,8,9};

delete[] arr;
delete[] arr2;
delete[] arr3;
```

- Елементите на масив се освбождават в обратен ред

### Задачи

**Задача 1** Да се напише функция merge, която приема два сортирани масива и ги обединява в намаляващ ред и
а) запазва само едно срещане на дублиращите се елементи
б) премахва изцяло дублиращите се елементи

#

**Задача 2** Да се напише програма, която приема естествено число n и n на брой двойки естествени числа.
Всяка двойка е растяща и отговаря на период, в който даден ученик е учил. Първото число е моментът на започване, а второто - на приключване на ученето. Последно се въвежда точка във времето.
Да се изведе колко на брой ученици учат в тази точка от времето.
<details open>
<summary>Пример</summary>
<b>Вход:</b><br>
3<br>
1 6<br>
2 4<br>
4 5<br>
4<br>
<b>Изход:</b><br>
2<br>
<b>Пояснение:</b><br>
{Ученик 1} учи в 4.<br>
{Ученик 2} завършва в 4, т.е. вече не учи.<br>
{Ученик 3} започва в 4, т.е. вече учи.<br>
</details>

#

**Задача 3** Да се напише функция, която добавя нов елемент в сортиран масив, така че той да остане сортиран.

#

**Задача 4** Да се напише програма, която брои инверсиите в масив.

#

**Задача 5** Да се напише програма, която разделя четните и нечетните елементи от един масив в два отделни.

#

**Задача 6** Да се напише функция reverse, която обръща масив от цели числа.

#

**Задача 7** Да се напише програма, която по въведени n числа и число k проверява дали съществува подредица, сумата на числата в която е равна на k. Ако има, да се изведат индексите на първия и последния член от подредицата. В противен случай да се изведе подходящо съобщение.

#

**Задача 8** Да се напише програма, която приема естествено число n и n на брой цели числа, и извежда нейната най-дълга монотонно растяща подредица.
<details open>
<summary>Пример</summary>
<b>Вход:</b><br>
9<br>
-5 5 4 2 6 7 7 10 4<br>
<b>Изход:</b><br>
2 6 7 7 10<br>
</details>

#

**Задача 9** Да се напише програма, която приема естествено число n и n на брой цели числа. Да се изведат числата, които са по-големи от сбора на всички след тях. Забележка: Сборът на нула числа е нула.
<details open>
<summary>Пример</summary>
<b>Вход:</b><br>
4<br>
5 1 2 1<br>
<b>Изход:</b><br>
5 2 1<br>
<b>Пояснение:</b><br>
5 > (1 + 2 + 1),<br>
2 > 1,<br>
1 > 0<br>
</details>

#

**Задача 10** Да се напише функция add, която приема три квадратни матрици и записва сбора на първата и втората в третата.

#

**Задача 11** Да се напише функция, която при подаден масив извежда на екрана всеки елемент, за който е изпълнено, че:
- е най-малък в реда си;
- е най-голям в колоната си.

#

💡**Задача 12** Изкачвате се по стълби. Можете да изкачвате по едно или по две стъпала с една крачка. По колко начина можете да изкачите сълбите, за да стигнете до горе. Стъпалата са n на брой.
